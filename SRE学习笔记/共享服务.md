为了保持清晰，我们将设定：

- **服务器 (Server)：** `10.0.0.100` (作为数据源、NFS 共享方)
    
- **客户端 (Client)：** `10.0.0.200` (作为数据接收方、NFS 挂载方)
    

---

## 🚀 I. NFS (Network File System) 使用示例

NFS 允许您将服务器上的目录共享给客户端，客户端挂载后可以像访问本地文件一样访问远程文件。

### 1. 🌐 NFS 服务器 (10.0.0.100) 配置

#### 步骤 1: 安装与创建共享目录

Bash

```
# 安装 NFS 服务器端软件包
sudo apt update
sudo apt install nfs-kernel-server -y

# 创建用于共享的目录
sudo mkdir -p /nfs_share
sudo chown nobody:nogroup /nfs_share
sudo chmod 777 /nfs_share
```

#### 步骤 2: 配置共享权限

编辑 `/etc/exports` 文件，添加共享目录及其权限。

Bash

```
sudo vim /etc/exports
```

**添加以下行：**

```
/nfs_share    10.0.0.200(rw,sync,no_subtree_check)
```

- `10.0.0.200`：只允许客户端 IP 访问。
    
- `rw`：读写权限。
    
- `sync`：同步写入，数据立即写入磁盘。
    

#### 步骤 3: 导出共享并启动服务

Bash

```
# 导出配置的共享目录
sudo exportfs -a

# 确保 NFS 服务启动并启用
sudo systemctl enable nfs-server
sudo systemctl start nfs-server
```

### 2. 💻 NFS 客户端 (10.0.0.200) 配置

#### 步骤 1: 安装客户端软件包

Bash

```
# 安装 NFS 客户端软件包
sudo apt update
sudo apt install nfs-common -y

# 创建本地挂载点
sudo mkdir -p /mnt/nfs_remote
```

#### 步骤 2: 挂载远程共享

Bash

```
# 挂载服务器的共享目录
sudo mount 10.0.0.100:/nfs_share /mnt/nfs_remote
```

#### 步骤 3: 示例验证

在客户端上进行操作：

Bash

```
# 在客户端 (10.0.0.200) 写入文件
echo "This is a test file from the client." | sudo tee /mnt/nfs_remote/client_test.txt
```

在服务器 (`10.0.0.100`) 上查看：

Bash

```
# 在服务器端 (10.0.0.100) 查看文件
cat /nfs_share/client_test.txt
# 输出: This is a test file from the client.
```

**结论：** 客户端已成功读写服务器上的文件。

---

## 🔄 II. Rsync (Remote Sync) 使用示例

Rsync 是一种高效的文件传输和同步工具，它只传输文件有变化的部分。通常用于单向、计划性的数据备份或同步。

### 1. 🌐 Rsync 服务器 (10.0.0.100) 配置

Rsync 默认通过 SSH 传输，**不需要额外的 Rsync 服务配置**，只需确保 SSH 服务运行即可。

#### 步骤 1: 准备同步目录

Bash

```
# 创建源数据目录
mkdir -p /data_source
echo "Initial data." > /data_source/file1.txt
```

### 2. 💻 Rsync 客户端 (10.0.0.200) 执行同步

#### 示例: 从服务器拉取数据 (Pull)

**目标：** 将服务器 `/data_source` 目录的内容同步到客户端 `/data_target`。

Bash

```
# 客户端 (10.0.0.200) 创建目标目录
mkdir -p /data_target

# 执行 rsync 命令（通过 SSH 协议）
# -a：归档模式 (保持权限、时间戳等)
# -v：详细输出
# --delete：删除目标目录中源目录没有的文件
rsync -av --delete user@10.0.0.100:/data_source/ /data_target/

# 验证客户端文件
ls /data_target/
cat /data_target/file1.txt
```

**结论：** 客户端成功从服务器同步了文件。

---

## ⚡ III. Sersync (Inotify + Rsync) 使用示例

Sersync 是一个基于 Linux **inotify** 机制的实时同步工具。它监控本地目录的事件（创建、修改、删除等），然后立即触发 Rsync 命令将更改推送到远程服务器。

### 1. 🌐 Sersync 服务器 (10.0.0.100) 配置

Sersync 在数据源端运行，负责监控和推送。

#### 步骤 1: 安装 Sersync (通常需要手动编译或下载预编译包)

**假设您已从 GitHub 下载并安装了 Sersync 的二进制文件**，并将其放在 `/usr/local/sersync/` 目录下。

#### 步骤 2: 配置 Rsync 目标（目标服务器需要运行 Rsync Daemon 或使用 SSH）

为了简化，我们继续使用 **SSH 方式**。确保服务器 `10.0.0.100` 可以免密 SSH 登录到 `10.0.0.200`（即设置 SSH 密钥）。

#### 步骤 3: 配置 Sersync XML 文件

创建或编辑 Sersync 的配置文件 `/usr/local/sersync/conf/confxml.xml`：

XML

```
<?xml version="1.0" encoding="utf-8"?>
<root>
    <conf>
        <localpath watch="/sersync_source">  <remotehost>
                <host name="10.0.0.200"/>   </remotehost>
        </localpath>
        <rsync>
            <path>/sersync_target</path>     <args>-avz --delete</args>      <auth start="false"/>           <user>user</user>               </rsync>
        <monitor>
            <interval>1</interval>          <blockduration>5</blockduration> </monitor>
    </conf>
</root>
```

#### 步骤 4: 启动 Sersync 监控

Bash

```
# 准备监控目录
mkdir -p /sersync_source

# 启动 sersync (使用后台运行和配置文件)
/usr/local/sersync/bin/sersync -d -r -o /usr/local/sersync/conf/confxml.xml
```

### 2. 💻 Sersync 客户端 (10.0.0.200) 准备

客户端只需要准备接收目录。

Bash

```
# 客户端 (10.0.0.200) 创建目标接收目录
mkdir -p /sersync_target
```

#### 示例: 实时同步验证

在服务器 (`10.0.0.100`) 上的被监控目录 `/sersync_source` 进行操作：

Bash

```
# 服务器 (10.0.0.100) 写入文件
echo "Real-time sync test." > /sersync_source/test_realtime.log

# 几秒后，检查客户端 (10.0.0.200) 的目标目录
ls /sersync_target/
cat /sersync_target/test_realtime.log
# 输出: Real-time sync test.
```

**结论：** Sersync 成功捕获文件创建事件，并实时通过 Rsync 推送到了客户端。

---

**下一步建议：**

您目前更关注哪一种同步方式的优化？例如，关于 **Rsync 的定时任务 (Cron Job)** 编写，或者 **Sersync 的 SSH 密钥免密配置**？