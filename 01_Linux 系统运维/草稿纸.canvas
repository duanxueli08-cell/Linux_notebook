{
	"nodes":[
		{"id":"95c90478d079e2e5","type":"text","text":"今日内容预告：\n\n\t- zookeeper集群的增删改查\n\t- zookeeper的leader选举流程\n\t- zookeeper集群调优\n\t- kafka集群环境搭建\n\t- kafka常用的脚本\n\t- kafka的调优\n\t- kafka对接ELFK架构;","x":-1160,"y":-810,"width":380,"height":270},
		{"id":"c14f99f25ce38542","type":"text","text":"# ZooKeeper 节点操作命令实战手册\n\n## 1. 节点查看操作\n\n\n### 查看指定路径节点\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 4] ls /oldboyedu \n[]\n\n[zk: 10.0.0.93:2181(CONNECTED) 18] ls /oldboyedu/linux92 \n[1, 2, 3]\n```\n\n## 2. 节点创建操作\n\n### 创建节点并存储数据\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 2] create /oldboyedu xixi\nCreated /oldboyedu\n```\n\n### 创建子节点不存储数据\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 5] create /oldboyedu/linux92\nCreated /oldboyedu/linux92\n```\n\n**验证创建结果：**\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 6] get /oldboyedu \nxixi\n\n[zk: 10.0.0.93:2181(CONNECTED) 7] get /oldboyedu/linux92\nnull\n```\n\n## 3. 节点数据修改操作\n\n### 更新节点数据\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 9] set /oldboyedu/linux92 haha\n\n[zk: 10.0.0.93:2181(CONNECTED) 10] get /oldboyedu/linux92\nhaha\n```\n\n## 4. 节点删除操作\n\n### 删除空节点\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 20] delete /oldboyedu/linux92/3 \n\n[zk: 10.0.0.93:2181(CONNECTED) 21] ls /oldboyedu/linux92 \n[1, 2]\n```\n\n### 递归删除非空节点\n```bash\n[zk: 10.0.0.93:2181(CONNECTED) 23] delete /oldboyedu/linux92 \nNode not empty: /oldboyedu/linux92\n\n[zk: 10.0.0.93:2181(CONNECTED) 25] deleteall /oldboyedu/linux92 \n\n[zk: 10.0.0.93:2181(CONNECTED) 26] ls /oldboyedu/linux92 \nNode does not exist: /oldboyedu/linux92\n```\n\n\n## ⚠️ 操作注意事项\n\n1. **删除限制**：\n   - `delete` 只能删除没有子节点的空目录\n   - `deleteall` 可以强制删除包含子节点的目录\n\n2. **数据存储**：\n   - 创建节点时可选择是否存储数据\n   - 未指定数据时默认值为 `null`\n\n3. **路径验证**：\n   - 操作前建议使用 `ls` 确认路径存在\n   - 删除后使用 `ls` 验证删除结果\n\n4. **错误处理**：\n   - 节点不存在：`Node does not exist`\n   - 节点非空：`Node not empty`\n","x":-680,"y":-810,"width":880,"height":1710},
		{"id":"7e47de16c6b1e037","type":"text","text":"## 📝 命令总结\n\n|命令|语法|用途|限制|\n|---|---|---|---|\n|**列表**|`ls <path>`|查看节点子列表|无|\n|**创建**|`create <path> [data]`|创建节点|路径不能重复|\n|**读取**|`get <path>`|获取节点数据|节点必须存在|\n|**更新**|`set <path> <data>`|修改节点数据|节点必须存在|\n|**删除**|`delete <path>`|删除空节点|节点必须无子节点|\n|**递归删除**|`deleteall <path>`|递归删除节点|无","x":320,"y":-810,"width":637,"height":359},
		{"id":"0219e6cc7345662c","type":"text","text":"|特性|**Raft 协议**|**ZooKeeper (ZAB) 协议**|\n|---|---|---|\n|**投票机制**|**硬承诺**|**软承诺 / 可更新**|\n|**规则**|在一个任期内，一旦投出一票，**绝对不能更改**。先到先得。|在**同一轮选举**中，如果收到**更优**的投票，可以**更新**自己的投票并重新广播。|\n|**“更优”标准**|(任期号, 日志索引)|(ZXID, SID)|\n|**比较逻辑**|1. 比较任期号  <br>2. 任期号相同则比较日志索引|1. 比较ZXID（64位数字，高32位是epoch，低32位是计数器）  <br>2. ZXID相同则比较SID（服务器ID）|","x":320,"y":-380,"width":637,"height":320},
		{"id":"f7fcb2df46d5d734","type":"text","text":"Kafka 的选举机制与前两者都不同，它**没有使用单一的主从复制共识算法（如 Raft 或 ZAB）来管理所有数据**，而是针对不同的元数据，采用了不同的、更轻量的策略。\n\n**1. Controller 选举**( 依赖于 ZooKeeper )\n\n**2. 分区 Leader 选举**\n\n总结：\n\n- **ZooKeeper (ZAB)** 和 **Raft** 是解决通用分布式一致性问题的**共识算法**。\n    \n- **Kafka** 是一个消息系统，它为了追求极致的性能，**借用 ZooKeeper 处理“元数据”的一致性**，而**数据本身**的复制和Leader选举则采用了更轻量、更快速的 **ISR 方案**。\n  \n**新版本的 Kafka (KIP-500) 正在移除对 ZooKeeper 的依赖，转而使用一个基于 Raft 协议的内置共识层来管理其元数据**，这进一步证明了 Raft 在工程上的成功和普适性。","x":320,"y":-20,"width":637,"height":465},
		{"id":"847cc6bc2827fd8b","type":"text","text":"### 总结\n\nZooKeeper 的 Leader 选举核心就是：\n\n1. **自荐发起**：每个节点都先投自己一票。\n    \n2. **广播拉票**：把自己的选票告诉所有人。\n    \n3. **公平PK**：遵循 **“数据版本（ZXID）优先，服务器ID其次”** 的规则，决定是否改票支持更优的候选者。\n    \n4. **多数胜出**：谁先获得**超过半数**的投票，谁就立即当选为 Leader。\n    \n5. **败者服从**：其他节点成为 Follower，接受 Leader 的领导。\n    \n\n这种基于“少数服从多数”的机制，保证了即使在部分节点宕机的情况下，集群也能快速恢复并正常工作，实现了高可用性。","x":320,"y":500,"width":637,"height":340},
		{"id":"3338c9ff8e9b8ded","type":"text","text":"\n### Zookeeper 集群调优检查清单（优先级从高到低）：\n\n1. **【必须】数据目录和事务日志目录使用不同的物理磁盘。**\n    \n2. **【必须】使用 SSD 硬盘。**\n    \n3. **【必须】设置合理的 JVM 堆内存（如 4G），并禁用 Swap。**\n    \n4. **【重要】根据数据量和网络情况，调整 `initLimit` 和 `syncLimit`。**\n    \n5. **【重要】开启并配置自动清理 (`autopurge`)。**\n    \n6. **【优化】对于写入频繁的集群，调整 `preAllocSize`。**","x":320,"y":900,"width":637,"height":260},
		{"id":"e29e5669aa06e728","type":"text","text":"Kafka 的 Leader 选举流程可以概括为：\n\n**Controller 从 ISR 列表中，按照列表顺序选取第一个存活副本作为新 Leader。**\n\n这种设计的**优点**是：\n\n- **极其高效快速**：没有复杂的投票过程，由 Controller 直接指定。\n    \n- **保证数据一致性**：优先从数据同步的副本中选举，避免了数据丢失。\n    \n\n这种设计与 Raft 或 ZAB 的民主投票制形成了鲜明对比，是 Kafka 为了实现**高吞吐量**而做出的重要架构权衡。","x":320,"y":1220,"width":637,"height":280},
		{"id":"6508606d5197219c","type":"text","text":"| **架构层级 (Layer)** | **关键服务 (Service)** | **主流工具 (Tool 1)**                             | **替代/互补工具 (Tool 2)**                       |\n| ---------------- | ------------------ | --------------------------------------------- | ------------------------------------------ |\n| **网关层**          | **API 网关**         | **Apache APISIX**                             | **Apache APISIX** / Spring Cloud Gateway   |\n| **服务层**          | **微服务实例** (业务逻辑)   | **Spring Boot** (Java)                        | **Go-Kit** (Go) / Node.js (Express/NestJS) |\n| **支撑层**          | **服务注册/发现**        | **Nacos** (阿里系)                               | **Consul** / Eureka (Netflix系)             |\n| **支撑层**          | **配置管理**           | **Apollo** (携程系)                              | **Nacos** / Spring Cloud Config            |\n| **支撑层**          | **异步通信**           | **Apache Kafka**                              | **RabbitMQ** / RocketMQ                    |\n| **支撑层**          | **链路追踪**           | **SkyWalking**                                | **Zipkin** / Jaeger                        |\n| **支撑层**          | **日志服务**           | **ELK Stack** (Elasticsearch/Logstash/Kibana) | **Prometheus + Loki** (云原生日志)              |\n| **数据层**          | **关系型数据库**         | **MySQL**                                     | **PostgreSQL** / TiDB (分布式)                |\n| **数据层**          | **缓存/NoSQL**       | **Redis**                                     | **MongoDB** / Memcached                    |\n| **部署层**          | **容器编排**           | **Kubernetes (K8s)**                          | **Docker Swarm** (小型环境)                    |","x":-680,"y":980,"width":880,"height":460}
	],
	"edges":[]
}